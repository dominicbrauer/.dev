---
import { Image } from "astro:assets";
import { actions } from "astro:actions";
import { getFormatedTime } from "@/lib/helpers";
import { DiscIcon, MicVocalIcon, SquarePauseIcon } from "@lucide/astro";
import Timeline from "@/components/SongDisplay/Timeline.astro";

const { data, error } = await Astro.callAction(actions.spotify.requestData, {});
---

{ (data && !error) ? (
	<div class="song-display cflex" data-offline={!data.is_playing}>
		<div class="cover-wrapper">
			<Image
				class="song-cover"
				src={data.song.album.images[0].url}
				width={data.song.album.images[0].width}
				height={data.song.album.images[0].height}
				alt="The album cover of the currently playing song."
			/>
		</div>
		<div class="song-information-wrapper">
			<span class="song-title">
				<a href={data.song.external_urls.spotify} target="_blank">
					{data.song.name}
				</a>
			</span>
			<MicVocalIcon class="mic-svg" />
			<div class="artists-wrapper">
				<span>
					{data.song.artists.map((artist, index) => (
						<>
							<a class="artist" href={artist.external_urls.spotify} target="_blank">
								{artist.name}
							</a>
							{index < data.song.artists.length - 1 && <span> • </span>}
						</>
					))}
				</span>
			</div>
			<DiscIcon class="disc-svg" />
			<span class="album-wrapper">
				<a href={data.song.album.external_urls.spotify} target="_blank">
					{data.song.album.name}
				</a>
			</span>
			<SquarePauseIcon class="pause-icon" />
			<span class="last-played">
				{data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused"}
			</span>
		</div>
		<Timeline
			progress={data.progress_ms}
			duration={data.song.duration_ms}
			fetched_at={data.fetched_at}
		/>
	</div>
	) : (
	<div class="song-display card cflex">
		<div class="song-information-wrapper">
			<span class="song-title">
				SongDisplay failed!
			</span>
			<MicVocalIcon class="mic-svg" />
			<div class="artists-wrapper">
				<span>-</span>
			</div>
			<DiscIcon class="disc-svg" />
			<span class="album-wrapper">-</span>
			<SquarePauseIcon class="pause-icon" />
			<span class="last-played">-</span>
		</div>
	</div>
)}

<style>
	@import url("@/styles/songDisplayAngle.css");

	.song-display[data-offline="true"]:global(.song-display .timeline) {
		display: none;
	}

	.song-display {
		gap: var(--size-s);
	}

	.song-information-wrapper {
		display: grid;
		width: 100%;
		grid-template-columns: 24px 1fr;
		gap: var(--size-2xs) var(--size-xs);
	}

	.cover-wrapper {
		position: relative;
		display: flex;
		overflow: visible;
		z-index: 0;
	}

	.song-cover {
		aspect-ratio: 1 / 1;
		width: 100%;
		height: auto;
		border: 2px solid var(--bg);
	}

	.song-display .cover-wrapper::after,
	.song-display .cover-wrapper::before {
		content: '';
		position: absolute;
		height: 100%;
		width: 100%;
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--primary));
		top: 50%;
		left: 50%;
		translate: -50% -50%;
		z-index: -1;
		padding: 2px;
		animation: borderRotate 6s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.song-display[data-offline="true"] .cover-wrapper::after,
	.song-display[data-offline="true"] .cover-wrapper::before {
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--text-muted));
		animation: borderRotate 12s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.cover-wrapper::before {
		filter: blur(.5em);
	}

	/* property angle moved to `src/styles/songDisplayAngle`
			to avoid breaking the code highlighting */
	@keyframes borderRotate {
		0% { --angle: 0deg; }
		100% { --angle: 360deg; }
	}

	.song-title {
		font-size: 1.5em;
		font-weight: 500;
		grid-column: span 2;
		margin-bottom: var(--size-3xs);
	}

	.song-title a {
		color: var(--text);
	}

	.mic-svg, .disc-svg {
		grid-column-start: 1;
	}

	.artists-wrapper, .album-wrapper, .listened {
		display: flex;
		grid-column-start: 2;
		align-items: center;
	}

	.song-information-wrapper svg {
		position: relative;
		aspect-ratio: 1 / 1;
		height: 24px;
		width: auto;
	}

	.song-display .last-played {
		font-style: italic;
		display: flex;
		align-items: center;
	}

	.song-display[data-offline="true"] .song-cover {
		filter: grayscale();
	}

	.song-display[data-offline="true"] .song-title a {
		color: var(--text-muted);
	}

	.song-display[data-offline="false"] .pause-icon,
	.song-display[data-offline="false"] .last-played {
		display: none;
	}
</style>

<script>
	import { getFormatedTime } from "@/lib/helpers";
	import { actions } from "astro:actions";

	const songDisplay = document.querySelector<HTMLDivElement>('.song-display');
	const songCover = document.querySelector<HTMLImageElement>('.song-display .song-cover');
	const songTitle = document.querySelector<HTMLAnchorElement>('.song-display .song-title a');
	const songArtistsWrapper = document.querySelector<HTMLSpanElement>('.song-display .artists-wrapper span');
	const songAlbum = document.querySelector<HTMLAnchorElement>('.song-display .album-wrapper a');
	const lastPlayed = document.querySelector<HTMLSpanElement>('.last-played');
	const timeLine = document.querySelector<HTMLDivElement>('.song-display .timeline');

	/**
	 * Updates the `SongDisplay` with
	 * the newest data available.
	 */
	async function update() {
		const { data, error } = await actions.spotify.requestData();

		if (error) {
			console.log("Error while fetching new song data: " + error);
			return;
		}

		data.is_playing ? timeLine?.classList.remove('hidden') : timeLine?.classList.add('hidden');

		window.dispatchEvent(new CustomEvent('updateTimeline', {
			detail: {
				progress: data.progress_ms,
				duration: data.song.duration_ms,
				fetched_at: data.fetched_at
			}
		}));

		songDisplay!.dataset.offline = String(!data.is_playing);

		songArtistsWrapper!.innerHTML = "";

		songCover!.src = data.song.album.images[0].url;
		songCover!.width = data.song.album.images[0].width;
		songCover!.height = data.song.album.images[0].height;

		songTitle!.innerText = data.song.name;
		songTitle!.href = data.song.external_urls.spotify;

		data.song.artists.forEach((artist, index) => {
			const entry = document.createElement('a');
			entry.classList.add('artist');
			entry.innerText = artist.name;
			entry.href = artist.external_urls.spotify;
			entry.target = "_blank";

			songArtistsWrapper?.appendChild(entry);

			if (index < data.song.artists.length - 1) {
				const separator = document.createElement('span');
				separator.innerText = " • ";
				songArtistsWrapper?.appendChild(separator);
			}
		});

		songAlbum!.innerText = data.song.album.name;
		songAlbum!.href = data.song.album.external_urls.spotify;

		lastPlayed!.innerText = !!data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused";
	}

	window.setInterval(update, 30000);
</script>
