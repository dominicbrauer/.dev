---
import { Image } from "astro:assets";
import { actions } from "astro:actions";
import { getFormatedTime } from "@/lib/helpers";
import "@/styles/songDisplay.css";
import { DiscIcon, MicVocalIcon, SquarePauseIcon } from "@lucide/astro";
import Timeline from "@/components/SongDisplay/Timeline.astro";

const { data, error } = await Astro.callAction(actions.spotify.requestData, {});
---

{ (data && !error) ? (
	<div class="song-display card cflex" data-offline={!data.is_playing}>
		<div class="cover-wrapper">
			<Image
				class="song-cover"
				src={data.song.album.images[0].url}
				width={data.song.album.images[0].width}
				height={data.song.album.images[0].height}
				alt="The album cover of the currently playing song."
			/>
		</div>
		<div class="song-information-wrapper">
			<span class="song-title">
				<a href={data.song.external_urls.spotify} target="_blank">
					{data.song.name}
				</a>
			</span>
			<MicVocalIcon class="mic-svg" />
			<div class="artists-wrapper">
				<span>
					{data.song.artists.map((artist, index) => (
						<>
							<a class="artist" href={artist.external_urls.spotify} target="_blank">
								{artist.name}
							</a>
							{index < data.song.artists.length - 1 && <span> • </span>}
						</>
					))}
				</span>
			</div>
			<DiscIcon class="disc-svg" />
			<span class="album-wrapper">
				<a href={data.song.album.external_urls.spotify} target="_blank">
					{data.song.album.name}
				</a>
			</span>
			<SquarePauseIcon class="pause-icon" />
			<span class="last-played">
				{data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused"}
			</span>
		</div>
		<Timeline
			progress={data.progress_ms}
			duration={data.song.duration_ms}
			fetched_at={data.fetched_at}
		/>
	</div>
	) : (
	<div class="song-display card cflex">
		<div class="song-information-wrapper">
			<span class="song-title">
				SongDisplay failed!
			</span>
			<MicVocalIcon class="mic-svg" />
			<div class="artists-wrapper">
				<span>-</span>
			</div>
			<DiscIcon class="disc-svg" />
			<span class="album-wrapper">-</span>
			<SquarePauseIcon class="pause-icon" />
			<span class="last-played">-</span>
		</div>
	</div>
)}

<style>
	.song-display[data-offline="true"]:global(.song-display .timeline) {
		display: none;
	}
</style>

<script>
	import { getFormatedTime } from "@/lib/helpers";
	import { actions } from "astro:actions";

	const songDisplay = document.querySelector<HTMLDivElement>('.song-display');
	const songCover = document.querySelector<HTMLImageElement>('.song-display .song-cover');
	const songTitle = document.querySelector<HTMLAnchorElement>('.song-display .song-title a');
	const songArtistsWrapper = document.querySelector<HTMLSpanElement>('.song-display .artists-wrapper span');
	const songAlbum = document.querySelector<HTMLAnchorElement>('.song-display .album-wrapper a');
	const lastPlayed = document.querySelector<HTMLSpanElement>('.last-played');
	const timeLine = document.querySelector<HTMLDivElement>('.song-display .timeline');

	/**
	 * Updates the `SongDisplay` with
	 * the newest data available.
	 */
	async function update() {
		const { data, error } = await actions.spotify.requestData();

		if (error) {
			console.log("Error while fetching new song data: " + error);
			return;
		}

		data.is_playing ? timeLine?.classList.remove('hidden') : timeLine?.classList.add('hidden');

		window.dispatchEvent(new CustomEvent('updateTimeline', {
			detail: {
				progress: data.progress_ms,
				duration: data.song.duration_ms,
				fetched_at: data.fetched_at
			}
		}));

		songDisplay!.dataset.offline = String(!data.is_playing);

		songArtistsWrapper!.innerHTML = "";

		songCover!.src = data.song.album.images[0].url;
		songCover!.width = data.song.album.images[0].width;
		songCover!.height = data.song.album.images[0].height;

		songTitle!.innerText = data.song.name;
		songTitle!.href = data.song.external_urls.spotify;

		data.song.artists.forEach((artist, index) => {
			const entry = document.createElement('a');
			entry.classList.add('artist');
			entry.innerText = artist.name;
			entry.href = artist.external_urls.spotify;
			entry.target = "_blank";

			songArtistsWrapper?.appendChild(entry);

			if (index < data.song.artists.length - 1) {
				const separator = document.createElement('span');
				separator.innerText = " • ";
				songArtistsWrapper?.appendChild(separator);
			}
		});

		songAlbum!.innerText = data.song.album.name;
		songAlbum!.href = data.song.album.external_urls.spotify;

		lastPlayed!.innerText = !!data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused";
	}

	window.setInterval(update, 30000);
</script>
