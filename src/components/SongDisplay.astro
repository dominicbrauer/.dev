---
import { Image } from "astro:assets";
import DiscIcon from "@lucide/astro/icons/disc";
import MicIcon from "@lucide/astro/icons/mic-vocal";
import Timeline from "@/components/Timeline.astro";
import type { SpotifyWebAPISong } from "@/lib/spotify/SpotifyWebAPI";
import { actions } from "astro:actions";

const { data, error } = await Astro.callAction(actions.spotify.request, {});
const song = JSON.parse(data!.song) as SpotifyWebAPISong;
---

{ !error &&
<div class="song-display cflex" data-offline={!data.is_playing}>
	<div class="cover-wrapper">
		<Image
			class="song-cover"
			src={song.album.images[0].url}
			width={song.album.images[0].width}
			height={song.album.images[0].height}
			alt="The album cover of the currently playing song."
		/>
	</div>
	<div class="song-information-wrapper">
		<span class="song-title">
			<a href={song.external_urls.spotify} target="_blank">
				{song.name}
			</a>
		</span>
		<MicIcon class="mic-svg" />
		<div class="artists-wrapper">
			<span>
				{song.artists.map((artist, index) => (
					<>
						<a class="artist" href={artist.external_urls.spotify} target="_blank">
							{artist.name}
						</a>
						{index < song.artists.length - 1 && <span> • </span>}
					</>
				))}
			</span>
		</div>
		<DiscIcon class="disc-svg" />
		<span class="album-wrapper">
			<a href={song.album.external_urls.spotify} target="_blank">
				{song.album.name}
			</a>
		</span>
	</div>
	<Timeline
		currentProgress={data.progress_ms}
		fetchedAt={data.fetched_at}
		totalDuration={song.duration_ms}
		class:list={[!data.is_playing && "hidden"]}
	/>
</div>
}

<style>
	.song-display {
		position: relative;
		border: 1px solid var(--border);
		padding: var(--size-l);
		width: var(--songdisplay-width);
		overflow: hidden;
		gap: var(--size-s);
		background-color: var(--bg);
	}

	.song-information-wrapper {
		display: grid;
		width: 100%;
		grid-template-columns: 24px 1fr;
		gap: var(--size-2xs) var(--size-xs);
	}

	.cover-wrapper {
		position: relative;
		display: flex;
		overflow: visible;
		z-index: 0;
	}

	.song-cover {
		aspect-ratio: 1 / 1;
		width: 100%;
		height: auto;
	}

	@property --angle {
		syntax: "<angle>";
		initial-value: 0deg;
		inherits: false;
	}

	.song-display[data-offline="false"] .cover-wrapper::after,
	.song-display[data-offline="false"] .cover-wrapper::before {
		content: '';
		position: absolute;
		height: 100%;
		width: 100%;
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--primary));
		top: 50%;
		left: 50%;
		translate: -50% -50%;
		z-index: -1;
		padding: 2px;
		animation: borderRotate 6s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.cover-wrapper::before {
		filter: blur(.5em);
	}

	@keyframes borderRotate {
		0% { --angle: 0deg; }
		100% { --angle: 360deg; }
	}

	.song-title {
		font-size: 1.5em;
		font-weight: 500;
		grid-column: span 2;
		margin-bottom: var(--size-3xs);
	}

	.song-title a {
		color: var(--text);
	}

	.mic-svg, .disc-svg {
		grid-column-start: 1;
	}

	.artists-wrapper, .album-wrapper {
		display: flex;
		grid-column-start: 2;
		align-items: center;
	}

	.song-information-wrapper svg {
		position: relative;
		aspect-ratio: 1 / 1;
		height: 24px;
		width: auto;
	}

	.pause-icon {
		display: none;
		position: absolute;
		aspect-ratio: 1 / 1;
		width: 96px;
		height: auto;
		inset: 0px;
		margin: auto;
		z-index: 100;
		stroke: var(--text);
	}

	.song-display[data-offline="true"] .song-cover {
		filter: grayscale();
	}

	.song-display[data-offline="true"] .song-title a {
		color: var(--text-muted);
	}

	.song-display[data-offline="true"] .pause-icon {
		display: initial;
	}
</style>

<script>
	import type { SpotifyWebAPISong } from "@/lib/spotify/SpotifyWebAPI";
	import { actions } from "astro:actions";

	const songDisplay = document.querySelector<HTMLDivElement>('.song-display');
	const songCover = document.querySelector<HTMLImageElement>('.song-display .song-cover');
	const songTitle = document.querySelector<HTMLAnchorElement>('.song-display .song-title a');
	const songArtistsWrapper = document.querySelector<HTMLSpanElement>('.song-display .artists-wrapper span');
	const songAlbum = document.querySelector<HTMLAnchorElement>('.song-display .album-wrapper a');
	const timeLine = document.querySelector<HTMLDivElement>('.song-display .timeline');

	/**
	 * Updates the `SongDisplay` with the newest data available.
	 */
	async function update() {
		const { data, error } = await actions.spotify.request();
		const song = JSON.parse(data!.song) as SpotifyWebAPISong;

		if (error) {
			console.log("Error while fetching new song data: " + error);
			return;
		}

		data.is_playing ? timeLine?.classList.remove('hidden') : timeLine?.classList.add('hidden');

		window.dispatchEvent(new CustomEvent('updateTimeline', {
			detail: {
				msProgress: data.progress_ms,
				msDuration: song.duration_ms,
				fetched_at: data.fetched_at
			}
		}));

		songDisplay!.dataset.offline = String(!data.is_playing);

		songArtistsWrapper!.innerHTML = "";
		
		songCover!.src = song.album.images[0].url;
		songCover!.width = song.album.images[0].width;
		songCover!.height = song.album.images[0].height;

		songTitle!.innerText = song.name;
		songTitle!.href = song.external_urls.spotify;

		song.artists.forEach((artist, index) => {
			const entry = document.createElement('a');
			entry.classList.add('artist');
			entry.innerText = artist.name;
			entry.href = artist.external_urls.spotify;
			entry.target = "_blank";

			songArtistsWrapper?.appendChild(entry);

			if (index < song.artists.length - 1) {
				const separator = document.createElement('span');
				separator.innerText = " • ";
				songArtistsWrapper?.appendChild(separator);
			}
		});

		songAlbum!.innerText = song.album.name;
		songAlbum!.href = song.album.external_urls.spotify;
	}

	const interval = window.setInterval(update, 30 * 1000);
</script>