---
import "@/styles/songDisplayAngle.css";
import { Image } from "astro:assets";
import DiscIcon from "@lucide/astro/icons/disc";
import MicIcon from "@lucide/astro/icons/mic-vocal";
import PauseIcon from "@lucide/astro/icons/square-pause";
import Timeline from "@/components/Timeline.astro";
import { actions } from "astro:actions";
import { getFormatedTime } from "@/lib/helpers";

const { data, error } = await Astro.callAction(actions.spotify.request, {});
---

{ !error && data &&
<div class="song-display cflex" data-offline={!data.is_playing}>
	<div class="cover-wrapper">
		<Image
			class="song-cover"
			src={data.song.album.images[0].url}
			width={data.song.album.images[0].width}
			height={data.song.album.images[0].height}
			alt="The album cover of the currently playing song."
		/>
	</div>
	<div class="song-information-wrapper">
		<span class="song-title">
			<a href={data.song.external_urls.spotify} target="_blank">
				{data.song.name}
			</a>
		</span>
		<MicIcon class="mic-svg" />
		<div class="artists-wrapper">
			<span>
				{data.song.artists.map((artist, index) => (
					<>
						<a class="artist" href={artist.external_urls.spotify} target="_blank">
							{artist.name}
						</a>
						{index < data.song.artists.length - 1 && <span> • </span>}
					</>
				))}
			</span>
		</div>
		<DiscIcon class="disc-svg" />
		<span class="album-wrapper">
			<a href={data.song.album.external_urls.spotify} target="_blank">
				{data.song.album.name}
			</a>
		</span>
		<PauseIcon class="pause-icon" />
		<span class="last-played">
			{data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused"}
		</span>
	</div>
	<Timeline
		progress={data.progress_ms}
		duration={data.song.duration_ms}
		fetched_at={data.fetched_at}
	/>
</div>
}

<style>
	.song-display {
		position: relative;
		border: 1px solid var(--border);
		padding: var(--size-l);
		width: var(--songdisplay-width);
		overflow: hidden;
		gap: var(--size-s);
		background-color: var(--bg);
	}

	.song-information-wrapper {
		display: grid;
		width: 100%;
		grid-template-columns: 24px 1fr;
		gap: var(--size-2xs) var(--size-xs);
	}

	.cover-wrapper {
		position: relative;
		display: flex;
		overflow: visible;
		z-index: 0;
	}

	.song-cover {
		aspect-ratio: 1 / 1;
		width: 100%;
		height: auto;
		border: 2px solid var(--bg);
	}

	.song-display .cover-wrapper::after,
	.song-display .cover-wrapper::before {
		content: '';
		position: absolute;
		height: 100%;
		width: 100%;
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--primary));
		top: 50%;
		left: 50%;
		translate: -50% -50%;
		z-index: -1;
		padding: 2px;
		animation: borderRotate 6s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.song-display[data-offline="true"] .cover-wrapper::after,
	.song-display[data-offline="true"] .cover-wrapper::before {
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--text-muted));
		animation: borderRotate 12s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.cover-wrapper::before {
		filter: blur(.5em);
	}

	/* property angle moved to `src/styles/songDisplayAngle`
		to avoid breaking the code highlighting */
	@keyframes borderRotate {
		0% { --angle: 0deg; }
		100% { --angle: 360deg; }
	}

	.song-title {
		font-size: 1.5em;
		font-weight: 500;
		grid-column: span 2;
		margin-bottom: var(--size-3xs);
	}

	.song-title a {
		color: var(--text);
	}

	.mic-svg, .disc-svg {
		grid-column-start: 1;
	}

	.artists-wrapper, .album-wrapper, .listened {
		display: flex;
		grid-column-start: 2;
		align-items: center;
	}

	.song-information-wrapper svg {
		position: relative;
		aspect-ratio: 1 / 1;
		height: 24px;
		width: auto;
	}

	.song-display .last-played {
		font-style: italic;
		display: flex;
		align-items: center;
	}

	.song-display[data-offline="true"] .song-cover {
		filter: grayscale();
	}

	.song-display[data-offline="true"] .song-title a {
		color: var(--text-muted);
	}

	.song-display[data-offline="false"] .pause-icon,
	.song-display[data-offline="false"] .last-played,
	.song-display[data-offline="true"]:global(.song-display .timeline) {
		display: none;
	}
</style>

<script>
	import { getFormatedTime } from "@/lib/helpers";
import { actions } from "astro:actions";

	const songDisplay = document.querySelector<HTMLDivElement>('.song-display');
	const songCover = document.querySelector<HTMLImageElement>('.song-display .song-cover');
	const songTitle = document.querySelector<HTMLAnchorElement>('.song-display .song-title a');
	const songArtistsWrapper = document.querySelector<HTMLSpanElement>('.song-display .artists-wrapper span');
	const songAlbum = document.querySelector<HTMLAnchorElement>('.song-display .album-wrapper a');
	const lastPlayed = document.querySelector<HTMLSpanElement>('.last-played');
	const timeLine = document.querySelector<HTMLDivElement>('.song-display .timeline');

	/**
	 * Updates the `SongDisplay` with
	 * the newest data available.
	 */
	async function update() {
		const { data, error } = await actions.spotify.request();

		if (error) {
			console.log("Error while fetching new song data: " + error);
			return;
		}

		data.is_playing ? timeLine?.classList.remove('hidden') : timeLine?.classList.add('hidden');

		window.dispatchEvent(new CustomEvent('updateTimeline', {
			detail: {
				progress: data.progress_ms,
				duration: data.song.duration_ms,
				fetched_at: data.fetched_at
			}
		}));

		songDisplay!.dataset.offline = String(!data.is_playing);

		songArtistsWrapper!.innerHTML = "";
		
		songCover!.src = data.song.album.images[0].url;
		songCover!.width = data.song.album.images[0].width;
		songCover!.height = data.song.album.images[0].height;

		songTitle!.innerText = data.song.name;
		songTitle!.href = data.song.external_urls.spotify;

		data.song.artists.forEach((artist, index) => {
			const entry = document.createElement('a');
			entry.classList.add('artist');
			entry.innerText = artist.name;
			entry.href = artist.external_urls.spotify;
			entry.target = "_blank";

			songArtistsWrapper?.appendChild(entry);

			if (index < data.song.artists.length - 1) {
				const separator = document.createElement('span');
				separator.innerText = " • ";
				songArtistsWrapper?.appendChild(separator);
			}
		});

		songAlbum!.innerText = data.song.album.name;
		songAlbum!.href = data.song.album.external_urls.spotify;

		lastPlayed!.innerText = !!data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused";
	}

	const interval = window.setInterval(update, 30 * 1000);
</script>